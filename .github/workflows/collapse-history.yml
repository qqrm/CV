name: collapse-history

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  actions: write

concurrency:
  group: collapse-history-${{ github.ref }}
  cancel-in-progress: false

jobs:
  collapse:
    name: Collapse history to single commit
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      ARCHIVE_PASSWORD: ${{ secrets.ARCHIVE_PASSWORD }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Create encrypted snapshot
        shell: bash
        run: |
          set -euo pipefail

          PREV_SHA=""
          if [ "${GITHUB_EVENT_NAME}" = "push" ]; then
            PREV_SHA="${{ github.event.before }}"
          elif git rev-parse HEAD^ >/dev/null 2>&1; then
            PREV_SHA="$(git rev-parse HEAD^)"
          fi

          if [ -z "${PREV_SHA}" ] || [ "${PREV_SHA}" = "0000000000000000000000000000000000000000" ]; then
            echo "No valid PREV_SHA available; skipping snapshot creation."
            exit 0
          fi

          git cat-file -e "${PREV_SHA}^{commit}"

          if [ -z "${ARCHIVE_PASSWORD:-}" ]; then
            echo "ARCHIVE_PASSWORD is not set; refusing to create encrypted snapshot." >&2
            exit 1
          fi

          echo "Creating encrypted snapshot from PREV_SHA ${PREV_SHA}."

          export_dir="$(mktemp -d)"
          entries_file="$(mktemp)"
          trap 'rm -rf "${export_dir}"; rm -f "${entries_file}"' EXIT

          git ls-tree -r "${PREV_SHA}" > "${entries_file}"

          while IFS=$'\t' read -r meta path; do
            [ -z "${path}" ] && continue

            case "${path}" in
              .snapshots/*)
                continue
                ;;
            esac

            mode="${meta%% *}"
            rest="${meta#* }"
            type="${rest%% *}"
            oid="${rest#* }"

            case "${type}" in
              blob)
                mkdir -p "${export_dir}/$(dirname "${path}")"
                if [ "${mode}" = "120000" ]; then
                  target="$(git cat-file -p "${oid}")"
                  ln -s "${target}" "${export_dir}/${path}"
                else
                  git cat-file -p "${oid}" > "${export_dir}/${path}"
                  if [ "${mode}" = "100755" ]; then
                    chmod +x "${export_dir}/${path}"
                  fi
                fi
                ;;
              commit)
                echo "Submodule detected at ${path}; refusing to snapshot." >&2
                exit 1
                ;;
              *)
                echo "Unsupported git object type '${type}' at ${path}; refusing to snapshot." >&2
                exit 1
                ;;
            esac
          done < "${entries_file}"

          if ! command -v 7z >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y p7zip-full
          fi

          mkdir -p .snapshots
          rm -f .snapshots/previous.repo.7z
          (
            cd "${export_dir}"
            7z a -t7z -mx=9 -mhe=on -p"${ARCHIVE_PASSWORD}" "${GITHUB_WORKSPACE}/.snapshots/previous.repo.7z" . >/dev/null 2>&1
          )

          echo "Encrypted snapshot written to .snapshots/previous.repo.7z"

      - name: Delete workflow run history
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          CURRENT_RUN_ID: ${{ github.run_id }}
        run: |
          set -euo pipefail

          echo "Deleting completed workflow run history for $REPO"
          deleted=0
          max_deleted=2000

          while true; do
            if [ "$deleted" -ge "$max_deleted" ]; then
              echo "Reached max_deleted=$max_deleted; stopping cleanup loop."
              break
            fi

            json="$(gh api "repos/$REPO/actions/runs?per_page=100&page=1")"
            ids="$(echo "$json" | jq -r --arg current "$CURRENT_RUN_ID" '.workflow_runs[] | select(.status == "completed" and (.id | tostring) != $current) | .id')"

            if [ -z "$ids" ]; then
              echo "No more completed runs to delete."
              break
            fi

            while IFS= read -r id; do
              [ -z "$id" ] && continue

              if [ "$deleted" -ge "$max_deleted" ]; then
                echo "Reached max_deleted=$max_deleted; stopping cleanup loop."
                break 2
              fi

              echo "DELETE run $id"
              gh api -X DELETE "repos/$REPO/actions/runs/$id" >/dev/null
              deleted=$((deleted + 1))
              sleep 0.2
            done <<< "$ids"
          done

          echo "Done. Deleted completed runs: $deleted"

      - name: Collapse history to single commit
        shell: bash
        env:
          GIT_AUTHOR_NAME: History Collapser
          GIT_AUTHOR_EMAIL: actions@github.com
          GIT_COMMITTER_NAME: History Collapser
          GIT_COMMITTER_EMAIL: actions@github.com
        run: |
          set -euo pipefail

          if git rev-list --max-count=2 HEAD | wc -l | grep -qx '1'; then
            echo "Repository already reduced to a single commit; nothing to do."
            exit 0
          fi

          echo "Current branch has multiple commits; rewriting history to a single commit."

          snapshot_message="Snapshot: ${GITHUB_SHA} [skip ci]"
          git checkout --orphan _collapsed_tmp
          git add -A
          git commit -m "${snapshot_message}" -m "skip-checks:true"
          git push origin HEAD:main --force-with-lease
