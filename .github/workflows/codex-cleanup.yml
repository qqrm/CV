name: codex-branch-cleanup

on:
  schedule:
    - cron: '0 */12 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: codex-branch-cleanup-${{ github.event_name }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  cleanup:
    name: Prune Codex branches and pull requests
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Run Codex cleanup
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const core = require('@actions/core');

            const MS_PER_HOUR = 60 * 60 * 1000;
            const CUTOFF_HOURS = 24;
            const cutoffMs = CUTOFF_HOURS * MS_PER_HOUR;
            const now = Date.now();
            const branchPrefix = 'codex/';
            const codexAuthor = 'github-codex[bot]';

            const { owner, repo } = context.repo;

            const repoInfo = await github.rest.repos.get({ owner, repo });
            const defaultBranch = repoInfo.data.default_branch;
            const protectedBranches = new Set([
              defaultBranch,
              'main',
              'master',
              'develop',
              'production',
              'prod',
            ]);

            const processedBranches = new Set();
            const deletedBranches = [];
            const skippedBranches = [];
            const closedPulls = [];

            const toHours = (ms) => Math.round(ms / MS_PER_HOUR);

            core.info(`Repository default branch: ${defaultBranch}`);
            core.info(`Evaluating branches with prefix "${branchPrefix}" older than ${CUTOFF_HOURS} hours.`);

            const branches = await github.paginate(
              github.rest.repos.listBranches,
              { owner, repo, per_page: 100 }
            );

            function parseCommitDate(branch) {
              const commit = branch?.commit?.commit;
              return (
                commit?.committer?.date ||
                commit?.author?.date ||
                null
              );
            }

            async function deleteBranch(ref, reason) {
              if (!ref) {
                core.warning(`Skipping branch deletion: empty ref encountered (${reason}).`);
                return false;
              }

              if (processedBranches.has(ref)) {
                core.info(`Branch ${ref} already processed (${reason}).`);
                return false;
              }

              if (!ref.startsWith(branchPrefix)) {
                core.info(`Skipping branch ${ref}: does not match prefix ${branchPrefix}.`);
                skippedBranches.push({ ref, reason: 'prefix-mismatch' });
                processedBranches.add(ref);
                return false;
              }

              if (protectedBranches.has(ref)) {
                core.warning(`Refusing to delete protected branch ${ref} (${reason}).`);
                skippedBranches.push({ ref, reason: 'protected' });
                processedBranches.add(ref);
                return false;
              }

              try {
                await github.rest.git.deleteRef({ owner, repo, ref: `heads/${ref}` });
                core.info(`Deleted branch ${ref} (${reason}).`);
                deletedBranches.push(ref);
                processedBranches.add(ref);
                return true;
              } catch (error) {
                if (error.status === 404) {
                  core.info(`Branch ${ref} already removed (${reason}).`);
                } else {
                  core.warning(`Failed to delete branch ${ref} (${reason}): ${error.message}`);
                }
                skippedBranches.push({ ref, reason: 'delete-failed', error: error.message });
                processedBranches.add(ref);
                return false;
              }
            }

            for (const branch of branches) {
              const name = branch.name;

              if (!name.startsWith(branchPrefix)) {
                continue;
              }

              if (protectedBranches.has(name)) {
                core.info(`Skipping branch ${name}: protected name.`);
                continue;
              }

              const commitDateIso = parseCommitDate(branch);
              if (!commitDateIso) {
                core.warning(`Skipping branch ${name}: unable to determine commit timestamp.`);
                skippedBranches.push({ ref: name, reason: 'no-commit-timestamp' });
                continue;
              }

              const commitTime = Date.parse(commitDateIso);
              if (Number.isNaN(commitTime)) {
                core.warning(`Skipping branch ${name}: invalid commit timestamp ${commitDateIso}.`);
                skippedBranches.push({ ref: name, reason: 'invalid-timestamp' });
                continue;
              }

              const ageMs = now - commitTime;
              const ageHours = toHours(ageMs);

              if (ageMs <= cutoffMs) {
                core.info(`Branch ${name} age ${ageHours}h is within retention.`);
                continue;
              }

              await deleteBranch(name, `stale (${ageHours}h old)`);
            }

            const pulls = await github.paginate(
              github.rest.pulls.list,
              { owner, repo, state: 'open', per_page: 100 }
            );

            for (const pr of pulls) {
              if (pr.user?.login !== codexAuthor) {
                continue;
              }

              const created = Date.parse(pr.created_at);
              if (!Number.isFinite(created)) {
                core.warning(`Skipping PR #${pr.number}: invalid created_at ${pr.created_at}.`);
                continue;
              }

              const ageMs = now - created;
              const ageHours = toHours(ageMs);

              if (ageMs <= cutoffMs) {
                core.info(`PR #${pr.number} is ${ageHours}h old; within retention.`);
                continue;
              }

              core.info(`Closing PR #${pr.number} (${pr.title}) opened by ${codexAuthor}; age ${ageHours}h.`);
              try {
                await github.rest.pulls.update({ owner, repo, pull_number: pr.number, state: 'closed' });
                closedPulls.push(pr.number);
              } catch (error) {
                core.warning(`Failed to close PR #${pr.number}: ${error.message}`);
                continue;
              }

              const headRef = pr.head?.ref;
              await deleteBranch(headRef, `closed PR #${pr.number}`);
            }

            core.info('Codex cleanup summary:');
            core.info(`  Deleted branches: ${deletedBranches.join(', ') || 'none'}`);
            core.info(`  Closed pull requests: ${closedPulls.join(', ') || 'none'}`);
            if (skippedBranches.length > 0) {
              for (const entry of skippedBranches) {
                const errorSuffix = entry.error ? ` (${entry.error})` : '';
                core.info(`  Skipped ${entry.ref}: ${entry.reason}${errorSuffix}`);
              }
            }
