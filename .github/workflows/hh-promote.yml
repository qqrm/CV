name: "HeadHunter: Promote"

on:
  schedule:
    - cron: '10 */4 * * *'
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: hh-promote-${{ github.ref }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always

jobs:
  preflight:
    runs-on: ubuntu-latest
    environment: prod
    outputs:
      ready: ${{ steps.secrets.outputs.ready }}
      missing: ${{ steps.secrets.outputs.missing }}
    steps:
      - name: Check HeadHunter secrets
        id: secrets
        shell: bash
        env:
          CLIENT_ID_PRIMARY: ${{ secrets.CLIENT_ID }}
          CLIENT_ID_FALLBACK: ${{ secrets.HH_CLIENT_ID }}
          CLIENT_SECRET_PRIMARY: ${{ secrets.CLIENT_SECRET }}
          CLIENT_SECRET_FALLBACK: ${{ secrets.HH_CLIENT_SECRET }}
          REFRESH_TOKEN_PRIMARY: ${{ secrets.REFRESH_TOKEN }}
          REFRESH_TOKEN_FALLBACK: ${{ secrets.HH_REFRESH_TOKEN }}
          RESUME_ID_RU_PRIMARY: ${{ secrets.RESUME_ID_RU }}
          RESUME_ID_RU_FALLBACK: ${{ secrets.HH_RESUME_ID_RU }}
          RESUME_ID_PM_RU_PRIMARY: ${{ secrets.RESUME_ID_PM_RU }}
          RESUME_ID_PM_RU_FALLBACK: ${{ secrets.HH_RESUME_ID_PM_RU }}
          RESUME_ID_EN_PRIMARY: ${{ secrets.RESUME_ID_EN }}
          RESUME_ID_EN_FALLBACK: ${{ secrets.HH_RESUME_ID_EN }}
        run: |
          set -euo pipefail

          summary_file="${GITHUB_STEP_SUMMARY:-}"
          if [[ -n "$summary_file" ]]; then
            echo "### HeadHunter promote prerequisites" >> "$summary_file"
          fi

          entries=(
            "CLIENT_ID_PRIMARY|CLIENT_ID_FALLBACK|OAuth client ID (CLIENT_ID or HH_CLIENT_ID)"
            "CLIENT_SECRET_PRIMARY|CLIENT_SECRET_FALLBACK|OAuth client secret (CLIENT_SECRET or HH_CLIENT_SECRET)"
            "REFRESH_TOKEN_PRIMARY|REFRESH_TOKEN_FALLBACK|OAuth refresh token (REFRESH_TOKEN or HH_REFRESH_TOKEN)"
            "RESUME_ID_RU_PRIMARY|RESUME_ID_RU_FALLBACK|Russian resume id (RESUME_ID_RU or HH_RESUME_ID_RU)"
            "RESUME_ID_PM_RU_PRIMARY|RESUME_ID_PM_RU_FALLBACK|Russian PM resume id (RESUME_ID_PM_RU or HH_RESUME_ID_PM_RU)"
            "RESUME_ID_EN_PRIMARY|RESUME_ID_EN_FALLBACK|English resume id (RESUME_ID_EN or HH_RESUME_ID_EN)"
          )

          missing=()
          for entry in "${entries[@]}"; do
            IFS='|' read -r primary_var fallback_var label <<<"$entry"
            primary="${!primary_var:-}"
            fallback="${!fallback_var:-}"
            if [[ -z "$primary" && -z "$fallback" ]]; then
              missing+=("$label")
              status="❌"
            else
              status="✅"
            fi
            if [[ -n "$summary_file" ]]; then
              echo "- ${status} ${label}" >> "$summary_file"
            fi
          done

          if (( ${#missing[@]} > 0 )); then
            missing_list="$(IFS=', '; echo "${missing[*]}")"
            printf '::warning::HeadHunter promote skipped; missing configuration: %s\n' \
              "$missing_list"
            if [[ -n "$summary_file" ]]; then
              echo >> "$summary_file"
              echo "> Configure the missing values in Settings → Environments → prod before re-running the workflow." >> "$summary_file"
            fi
            echo "ready=false" >> "$GITHUB_OUTPUT"
            echo "missing=$missing_list" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "ready=true" >> "$GITHUB_OUTPUT"
          echo "missing=" >> "$GITHUB_OUTPUT"

  promote:
    needs: preflight
    if: needs.preflight.outputs.ready == 'true'
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - name: Refresh access token
        id: token
        shell: bash
        env:
          CLIENT_ID_PRIMARY: ${{ secrets.CLIENT_ID }}
          CLIENT_ID_FALLBACK: ${{ secrets.HH_CLIENT_ID }}
          CLIENT_SECRET_PRIMARY: ${{ secrets.CLIENT_SECRET }}
          CLIENT_SECRET_FALLBACK: ${{ secrets.HH_CLIENT_SECRET }}
          REFRESH_TOKEN_PRIMARY: ${{ secrets.REFRESH_TOKEN }}
          REFRESH_TOKEN_FALLBACK: ${{ secrets.HH_REFRESH_TOKEN }}
        run: |
          set -euo pipefail

          client_id="${CLIENT_ID_PRIMARY:-}"
          if [[ -z "$client_id" ]]; then
            client_id="${CLIENT_ID_FALLBACK:-}"
          fi

          client_secret="${CLIENT_SECRET_PRIMARY:-}"
          if [[ -z "$client_secret" ]]; then
            client_secret="${CLIENT_SECRET_FALLBACK:-}"
          fi

          refresh_token="${REFRESH_TOKEN_PRIMARY:-}"
          if [[ -z "$refresh_token" ]]; then
            refresh_token="${REFRESH_TOKEN_FALLBACK:-}"
          fi

          missing=()
          [[ -z "$client_id" ]] && missing+=("CLIENT_ID or HH_CLIENT_ID")
          [[ -z "$client_secret" ]] && missing+=("CLIENT_SECRET or HH_CLIENT_SECRET")
          [[ -z "$refresh_token" ]] && missing+=("REFRESH_TOKEN or HH_REFRESH_TOKEN")
          if (( ${#missing[@]} > 0 )); then
            printf 'Missing secrets: %s\n' "$(IFS=', '; echo "${missing[*]}")" >&2
            exit 1
          fi

          response=$(curl -sS -X POST https://hh.ru/oauth/token \
            --data-urlencode grant_type=refresh_token \
            --data-urlencode client_id="${client_id}" \
            --data-urlencode client_secret="${client_secret}" \
            --data-urlencode refresh_token="${refresh_token}")
          token=$(echo "$response" | jq -r '.access_token')
          if [[ -z "$token" || "$token" == "null" ]]; then
            message=$(echo "$response" | jq -r '.error_description // .error // empty')
            if [[ -n "$message" ]]; then
              echo "HeadHunter OAuth error: ${message}" >&2
            else
              echo "Unable to extract access token" >&2
            fi
            exit 1
          fi
          echo "::add-mask::$token"
          echo "access_token=$token" >> "$GITHUB_OUTPUT"

      - name: Promote resumes in HeadHunter search
        shell: bash
        env:
          ACCESS_TOKEN: ${{ steps.token.outputs.access_token }}
          RESUME_ID_RU_PRIMARY: ${{ secrets.RESUME_ID_RU }}
          RESUME_ID_RU_FALLBACK: ${{ secrets.HH_RESUME_ID_RU }}
          RESUME_ID_PM_RU_PRIMARY: ${{ secrets.RESUME_ID_PM_RU }}
          RESUME_ID_PM_RU_FALLBACK: ${{ secrets.HH_RESUME_ID_PM_RU }}
          RESUME_ID_EN_PRIMARY: ${{ secrets.RESUME_ID_EN }}
          RESUME_ID_EN_FALLBACK: ${{ secrets.HH_RESUME_ID_EN }}
        run: |
          set -euo pipefail

          resolve_id() {
            if [[ -n "$1" ]]; then
              printf '%s\n' "$1"
            else
              printf '%s\n' "$2"
            fi
          }

          fetch_timestamp() {
            local resume_id="$1"
            local label="$2"
            local response
            if ! response=$(curl -sS "https://api.hh.ru/resumes/${resume_id}" \
                -H "Authorization: Bearer ${ACCESS_TOKEN}" \
                --fail); then
              echo "Failed to fetch metadata for ${label} (${resume_id})" >&2
              return 1
            fi
            local timestamp
            timestamp=$(echo "$response" | jq -r '.updated_at // .updated // .publication_time // .publication_date // .publish_date // empty')
            if [[ -z "$timestamp" || "$timestamp" == "null" ]]; then
              echo "Resume ${label} (${resume_id}) metadata does not expose a publication timestamp" >&2
              return 1
            fi
            printf '%s\n' "$timestamp"
          }

          resume_id_ru=$(resolve_id "${RESUME_ID_RU_PRIMARY:-}" "${RESUME_ID_RU_FALLBACK:-}")
          resume_id_pm_ru=$(resolve_id "${RESUME_ID_PM_RU_PRIMARY:-}" "${RESUME_ID_PM_RU_FALLBACK:-}")
          resume_id_en=$(resolve_id "${RESUME_ID_EN_PRIMARY:-}" "${RESUME_ID_EN_FALLBACK:-}")

          summary_file="${GITHUB_STEP_SUMMARY:-}"
          if [[ -n "$summary_file" ]]; then
            echo "### Resume promotion results" >> "$summary_file"
          fi
          entries=(
            "${resume_id_ru}:Russian resume"
            "${resume_id_pm_ru}:Russian PM resume"
            "${resume_id_en}:English resume"
          )
          status=0
          for entry in "${entries[@]}"; do
            IFS=":" read -r resume_id label <<<"$entry"
            if [[ -z "$resume_id" ]]; then
              echo "Skipping ${label}: resume id is not configured" >&2
              if [[ -n "$summary_file" ]]; then
                echo "- ⚠️ ${label} (missing RESUME_ID)" >> "$summary_file"
              fi
              continue
            fi

            echo "Promoting ${label} (${resume_id})"
            previous_timestamp=$(fetch_timestamp "$resume_id" "$label") || {
              status=1
              if [[ -n "$summary_file" ]]; then
                echo "- ❌ ${label} (failed to read current timestamp)" >> "$summary_file"
              fi
              continue
            }

            if ! previous_epoch=$(date -u -d "$previous_timestamp" +%s 2>/dev/null); then
              echo "Unable to parse timestamp '${previous_timestamp}' for ${label}" >&2
              status=1
              if [[ -n "$summary_file" ]]; then
                echo "- ❌ ${label} (unparsable timestamp ${previous_timestamp})" >> "$summary_file"
              fi
              continue
            fi

            if curl -sS -X POST "https://api.hh.ru/resumes/${resume_id}/publish" \
                -H "Authorization: Bearer ${ACCESS_TOKEN}" \
                -H "Content-Length: 0" \
                --fail > /dev/null; then
              # Wait briefly to ensure the HeadHunter API persists the new timestamp
              sleep 2

              current_timestamp=$(fetch_timestamp "$resume_id" "$label") || {
                status=1
                if [[ -n "$summary_file" ]]; then
                  echo "- ❌ ${label} (failed to confirm timestamp update)" >> "$summary_file"
                fi
                continue
              }

              if ! current_epoch=$(date -u -d "$current_timestamp" +%s 2>/dev/null); then
                echo "Unable to parse updated timestamp '${current_timestamp}' for ${label}" >&2
                status=1
                if [[ -n "$summary_file" ]]; then
                  echo "- ❌ ${label} (unparsable timestamp ${current_timestamp})" >> "$summary_file"
                fi
                continue
              fi

              if (( current_epoch > previous_epoch )); then
                if [[ -n "$summary_file" ]]; then
                  echo "- ✅ ${label} (${previous_timestamp} → ${current_timestamp})" >> "$summary_file"
                fi
              else
                echo "Timestamp for ${label} did not increase" >&2
                status=1
                if [[ -n "$summary_file" ]]; then
                  echo "- ❌ ${label} (timestamp unchanged: ${previous_timestamp} → ${current_timestamp})" >> "$summary_file"
                fi
              fi
            else
              echo "Failed to promote ${label}" >&2
              status=1
              if [[ -n "$summary_file" ]]; then
                echo "- ❌ ${label}" >> "$summary_file"
              fi
            fi
          done
          exit $status
